import cv2
import time
import numpy as np
import serial
from ultralytics import YOLO

# ================= CONFIGURATION =================
SERIAL_PORT = "/dev/ttyUSB0" 
BAUD = 115200
WEIGHTS = "/home/neythz/Documents/runs/detect/train/weights/best.pt" // Change base on your best.pt model path

# Performance Settings
CAM_INDEX = 0
IMGSZ = 640
CONF_THRESH = 0.25
DETECTION_TIME = 10.0 

# Robot Geometry
L1, L2, TCP = 120.0, 120.0, 40.0
SAFE_Z = 130.0
DT = 0.02
Kp = 5.0

# Poses
CAMERA_POSE = np.array([150.0, 0.0, 180.0])
SOURCE_RACK = [np.array([150, -30, 40]), np.array([150, 0, 40]), np.array([150, 30, 40])]
TARGET_RACK = {
    "RED": np.array([0, 150, 40]), 
    "GREEN": np.array([30, 150, 40]), 
    "BLUE": np.array([60, 150, 40])
}

# HSV Ranges
HSV_RANGES = {
    "RED": [((0, 100, 80), (10, 255, 255)), ((170, 100, 80), (180, 255, 255))],
    "GREEN": [((35, 80, 80), (85, 255, 255))],
    "BLUE":  [((90, 80, 80), (130, 255, 255))]
}
KERNEL = np.ones((5, 5), np.uint8)

# ================= CORE FUNCTIONS =================

def detect_color_hsv(roi):
    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
    h, w = hsv.shape[:2]
    scores = {}

    for color, ranges in HSV_RANGES.items():
        mask = np.zeros((h, w), dtype=np.uint8)
        for lower, upper in ranges:
            mask |= cv2.inRange(hsv, np.array(lower), np.array(upper))
        
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, KERNEL)
        scores[color] = cv2.countNonZero(mask)

    best_color = max(scores, key=scores.get)
    if scores[best_color] / (h * w) < 0.15:
        return "UNKNOWN"
    return best_color

def fk(q):
    t1, t2, t3 = q
    r = L1*np.cos(t2) + L2*np.cos(t2+t3) + TCP
    z = L1*np.sin(t2) + L2*np.sin(t2+t3)
    return np.array([r*np.cos(t1), r*np.sin(t1), z])

def move_to(target_xyz, current_q, ser):
    q = current_q.copy()
    target_above = np.array([target_xyz[0], target_xyz[1], SAFE_Z])
    
    for goal in [target_above, target_xyz]:
        while np.linalg.norm(fk(q) - goal) > 2.0:
            x = fk(q)
            err = goal - x
            t1, t2, t3 = q
            r = L1*np.cos(t2) + L2*np.cos(t2+t3) + TCP
            J = np.zeros((3,3))
            J[0,0] = -r*np.sin(t1); J[0,1] = -np.cos(t1)*(L1*np.sin(t2)+L2*np.sin(t2+t3)); J[0,2] = -np.cos(t1)*(L2*np.sin(t2+t3))
            J[1,0] = r*np.cos(t1); J[1,1] = -np.sin(t1)*(L1*np.sin(t2)+L2*np.sin(t2+t3)); J[1,2] = -np.sin(t1)*(L2*np.sin(t2+t3))
            J[2,1] = L1*np.cos(t2)+L2*np.cos(t2+t3); J[2,2] = L2*np.cos(t2+t3)
            
            q_dot = np.linalg.pinv(J) @ (Kp * err)
            q += q_dot * DT
            
            ser.write(f"J:{np.degrees(q)[0]:.2f},{np.degrees(q)[1]:.2f},{np.degrees(q)[2]:.2f}\n".encode())
            time.sleep(DT)
    return q

# ================= MAIN EXECUTION =================

ser = serial.Serial(SERIAL_PORT, BAUD, timeout=1)
model = YOLO(WEIGHTS)
cap = cv2.VideoCapture(CAM_INDEX)
current_q = np.array([0.0, 0.4, -0.7]) 
time.sleep(2)

try:
    for tube_pos in SOURCE_RACK:
        # 1. PICK
        current_q = move_to(tube_pos, current_q, ser)
        ser.write(b"GRIP:CLOSE\n")
        time.sleep(0.5)
        
        # 2. MOVE TO CAMERA
        current_q = move_to(CAMERA_POSE, current_q, ser)
        
        # 3. 10 SECOND SILENT DETECTION
        votes = {"RED": 0, "GREEN": 0, "BLUE": 0}
        start_time = time.time()
        
        while time.time() - start_time < DETECTION_TIME:
            ret, frame = cap.read()
            if not ret: continue
            
            results = model(frame, imgsz=IMGSZ, conf=CONF_THRESH, verbose=False)[0]
            
            if results.boxes is not None:
                for box in results.boxes:
                    x1, y1, x2, y2 = map(int, box.xyxy[0])
                    roi = frame[y1:y2, x1:x2]
                    if roi.size == 0: continue
                    
                    color_label = detect_color_hsv(roi)
                    if color_label in votes:
                        votes[color_label] += 1

        final_color = max(votes, key=votes.get) if sum(votes.values()) > 0 else "RED"

        # 4. PLACE
        target_pos = TARGET_RACK.get(final_color, TARGET_RACK["RED"])
        current_q = move_to(target_pos, current_q, ser)
        ser.write(b"GRIP:OPEN\n")
        time.sleep(0.5)

finally:
    cap.release()
    ser.close()
